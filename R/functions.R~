############################################################
## generally useful helper functions
############################################################

## a quick and dirty multi-grepl function:
## wow, can easily do this with regex...?
mgrepl <- function(patterns, x, ignore.case = FALSE,
                      strict = 0, fuzzy = FALSE, perl = FALSE){
    require(plyr)
    f <- if (fuzzy){ agrepl } else { grepl }
    bool_df <- ldply(patterns, function(pattern){
        f(pattern, x, ignore.case = ignore.case, perl = perl)
    })
    colSums(bool_df) > strict
}

# a quicker and dirtier multi-grep function:
mgrep <- function(patterns, x, ignore.case = FALSE,
                     strict = 0, fuzzy = FALSE, value = FALSE, perl = FALSE){

    i <- mgrepl(patterns, x, ignore.case = ignore.case,
              strict = strict, fuzzy = fuzzy, perl = perl)

    if(value){
        x[i]
    } else {
        seq_along(x)[i]        
    }
}

## trail leading and trailing whitespace:
trim <- function(x){ gsub("^\\s+|\\s+$", "", x)}

## find all the words two strings share (useful for finding
## the right row in the excel file using insect name):
stringIntersect <- function(s1, s2){
    require(plyr)
    s <- strsplit(gsub("[^[:alnum:]]", " ", c(s1,s2)), " +")
    s <- llply(s, function(si){
        si[which(si != "")]
    })
    intersect(tolower(s[[1]]), tolower(s[[2]]))
}

## see if string2 contains all of string 1 (excluding non alphanum)
stringContains <- function(s1, s2){
    s <- strsplit(gsub("[^[:alnum:]]", " ", c(s1,s2)), " ")
    all(tolower(s[[1]]) %in% tolower(s[[2]]))
}

## remove parentheses from a string
removeParens <- function(s){
    gsub("(?=\\().*?(?<=\\))", "", s, perl=T)
}

## test list of strings for containment
## in another list of strings
aIn <- function(s1, s2, ic = TRUE, md = 0.1){

    if (all(is.na(s1) & all(is.na(s2)))){ return(TRUE) }
    
    s1 <- na.omit(s1)
    s2 <- na.omit(s2)
    sapply(s1, function(x){
        any(agrepl(x, s2, ignore.case = ic, max.distance = md))
    })
}

## create a random data frame of numbers
RandDF <- function(rows, cols){
    stopifnot(cols <= 26)
    data <- sample(1:(rows * cols), rows * cols, replace = TRUE)
    tmp <- data.frame(matrix(data, nrow = rows, ncol = cols))
    colnames(tmp) <- letters[1:cols]
    tmp
}

## segment a vector into bins
SegmentVec <- function(vec, num.segs, ordered = TRUE){

    if(ordered){
        vec <- sort(vec, na.last = FALSE)
    }

    segs <- sort(rep(1:num.segs,length = length(vec)))
    segments <- lapply(1:num.segs, function(i) vec[which(segs == i)] )
    return(segments)
}

## insert new values into specified indices in a
## vector
insert.vals <- function(vector, values, indices){
    if(length(values) != length(indices)){
        values <- rep(values, length(indices))
    }
    indices <- sort(indices)
    index <- indices[1]
    new_value <- values[1]
    if(index == 1){
        vector <- c(new_value, vector)
    } else if(index >= length(vector)){
        vector <- c(vector, new_value)
    } else {
        vector <- c(
            vector[1:(index - 1)],
            values[1],
            vector[index:length(vector)]
        )
    }
    if(length(indices) != 1){
        indices <- indices[2:length(indices)]
        values <- values[2:length(values)]
        vector <- insert.vals(vector, values, indices)
    }
    vector
}

mgsub <- function(pattern, replacement, x, ...) {
  if (length(pattern)!=length(replacement)) {
    stop("pattern and replacement do not have the same length.")
  }
  result <- x
  for (i in 1:length(pattern)) {
    result <- gsub(pattern[i], replacement[i], result, ...)
  }
  result
}

fixDates <- function(date, format = "%d/%m/%Y"){
    months <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep",
                "Oct", "Nov", "Dec")
    as.Date(gsub("/0", "/200",
                 mgsub(c(months, "-", " ", "208", "some subset of:",
                            "dates not specified"),
                          c(1:12, "/", "/", "2008", "", ""),
                          trim(removeParens(date)))
                 ),
            format = format)
}

symdiff <- function(A, B){
    c(setdiff(A, B), setdiff(B, A))
}

inquireReload <- function(yesNoQuestion, answer = NULL){
    if(is.null(answer)){
        ans <- readline(yesNoQuestion)
        while(ans != "n" & ans != "y"){
            ans <- readline("please answer y/n: ")
        }
    } else {
        return(answer)
    }
    return(ans)
}

normalizeColumn <- function(df, colname){
    x <- df[, colname]
    new_x <- (x - min(x, na.rm = TRUE)) /
        (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
    df[,paste("Normalized", colname, sep = "")] <- new_x
    df
}

## count number of values since the
## last TRUE value in a given vector i.e.
## c(FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE)
## -> c(1, 0, 0, 1, 2, 0, 1, 2, 3, 0)
## note: this is biased towards 1's...
sumToIndex <- function(vector){
    vec_length <- length(vector)
    new_vector <- rep(0,vec_length)
    valued_indices <- which(vector == TRUE)
    j <- 1
    for (i in 1:vec_length){
        if(i %in% valued_indices){
            new_vector[i] <- 0
            j <- 1
        } else {
            new_vector[i] <- j
            j <- j + 1
        }
    }
    new_vector
}



############################################################
############################################################
